[{"title":"Dubbo","date":"2019-08-13T06:22:57.388Z","path":"2019/08/13/Dubbo总结/","text":"浅谈Dubbo 什么是Dubbo Dubbo是分布式RPC框架 Dubbo的三大核心能力 面向接口的远程方法调用 智能容错和负载均衡 服务自动注册和发现 Dubbo架构图 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo使用步骤 服务端 定义一个接口，如： 123public interface CheckitemService &#123; void add(CheckItem checkItem);&#125; 写实现类 1234567891011121314@Service(interfaceClass = CheckitemService.class)@Transactionalpublic class CheckitemServiceImpl implements CheckitemService&#123; @Autowired private CheckitemDao checkitemDao; /** * 新增检查项 * @param checkItem */ @Override public void add(CheckItem checkItem) &#123; checkitemDao.add(checkItem); &#125;&#125; 写事务的配置文件 12345678910&lt;!--事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--开启事务控制的注解支持 注意：此处必须加入proxy-target-class=\"true\" 需要进行事务控制，会由Spring框架产生代理对象 Dubbo需要将Service发布为服务，要求必须使用cglib创建代理对象 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; 写服务端配置文件 12345678&lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;!-- 指定应用名称 --&gt;&lt;dubbo:application name=\"health_service\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!--批量扫描--&gt;&lt;dubbo:annotation package=\"com.itheima.service\"/&gt; @service注解可以写成xml配置文件的形式 12345678910&lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;!-- 指定应用名称 --&gt;&lt;dubbo:application name=\"health_service\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!-- 注册一个Bean --&gt;&lt;bean id=\"checkitemService\" class=\"cn.itcast.dubbo.service.impl.CheckitemServiceImpl\"&gt;&lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface=\"cn.itcast.dubbo.service.CheckitemService\" ref=\"checkitemService\"/&gt; 注意:在一个实现类(CheckitemServiceImpl)加上@Transactional注解时,Spring会为此类基于JDK动态代理技术创建代理对象,如com.sun.proxy.$Proxy42,而我们在xml文件中注册Bean的时候，使用的class仍然为CheckitemServiceImpl,所以就会出现服务提供者无法注册到Dubbo中的情况。 解决方法: 第一步：在服务端事务的配置文件中开启事务控制的注解支持 1&lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; 第二步：在Service注解中加入interfaceClass属性，值为CheckitemService.class，作用是指定服务的接口类型。此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是CheckitemService接口。 消费端 配置文件 123456&lt;!--指定应用名称--&gt;&lt;dubbo:application name=\"health_web\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!--批量扫描--&gt;&lt;dubbo:annotation package=\"com.itheima.controller\"/&gt; 订阅服务 1234567@RestController //将当前处理器中所有方法的返回值都转换成json数据.@RequestMapping(\"/checkitem\")public class CheckitemController &#123; @Reference private CheckitemService checkitemService;&#125; 问题：在服务消费者工程(dubbodemo_consumer)中只是引用了CheckitemService接口，并没有提供实现类，Dubbo是如何做到远程调用的？ Dubbo底层是基于代理技术为CheckitemService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。 启动时检查 1&lt;dubbo:consumer check=\"false\"/&gt; ​ 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。建议在开发阶段将check值设置为false，在生产环境下改为true。 负载均衡 负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机(random)、轮询(roundrobin)、最少活跃调用数、一致性Hash），缺省为random随机调用。配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 服务提供者 123456789101112131415//在服务提供者一方配置负载均衡@Service(interfaceClass = CheckitemService.class,loadbalance = \"roundrobin\")@Transactionalpublic class CheckitemServiceImpl implements CheckitemService&#123; @Autowired private CheckitemDao checkitemDao; /** * 新增检查项 * @param checkItem */ @Override public void add(CheckItem checkItem) &#123; checkitemDao.add(checkItem); &#125;&#125; 服务消费者 1234567@RestController //将当前处理器中所有方法的返回值都转换成json数据.@RequestMapping(\"/checkitem\")public class CheckitemController &#123; @Reference(check = false, loadbalance = \"roundrobin\") private CheckitemService checkitemService;&#125;","categories":[],"tags":[]},{"title":"数据库总结","date":"2019-07-28T23:40:46.356Z","path":"2019/07/29/数据库总结/","text":"JAVA连接Mysql数据库的发展JDBC使用步骤 注册驱动 1Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 1Connection conn = DriverManger.getConnection(\"jdbc:mysql://主机:端口/数据库\",\"数据库用户名\",\"数据库密码\"); 获取Statement对象 1Statement stmt = conn.createStatement(); 使用Statement对象执行sql语句 增删改： 12int i = stmt.executeUpdate(\"sql语句\")；i为执行这条sql语句改变的行数 查： 1ResultSet rs = stmt.executeQuery(\"sql语句\")； 释放资源:在java中,释放资源时或者关闭流时,按照先创建后关闭的原则 增删改: 12stmt.close();conn.close(); 查 123rs.close();stmt.close();conn.close(); JDBC的缺点 操作数据库都需要创建连接,操作完成还需要关闭连接 创建连接和关闭连接可能比执行sql需要的时间都长 一个网站需要高频繁访问时数据库,如果短时间频繁的访问数据库服务器,就容易造成服务器的宕机 连接池为什么要使用连接池？ 优点:连接池中保存了一些数据库连接,这些连接时可以重复的.解省了数据库资源的消耗。 c3p0使用步骤 导包 编写连接池配置文件c3p0-config.xml,配置对应的参数 创建连接池对象 1ComPooledDataSource cpds = new ComPooledDataSource(); 从连接池中获取对象 1conn = cpds.getConnection(); 获取发送sql语句的对象 1stmt = cpds.prepareStatement(sql)； 操作数据库 1stmt.executeUpdate; stmt.executeQuery; 释放资源 Druid使用步骤 导包 创建properties文件,设置对应参数 1234url=jdbc:mysql://主机:端口/数据库名username=用户名password=密码driverClassName=com.mysql.jdbc.Driver 加载properties文件到Properties对象中 12Properties info = new Properties();info.load(new fileInputStream(\"配置文件名.properties\"))； 创建连接池,使用配置文件中的参数 1DataSource dataSource = DruidDataSourceFactory.createDataSource(info); 从连接池中获取连接 1conn = dataSource.getConnection(); 获取发送sql语句对象 1pstmt = conn.prepareStatement(\"sql语句\"); 操作数据库 1pstmt.executeQuery();pstmt.executeUpdate(); 释放资源 JdbcTemplate优点: 将查询到的数据直接封装成对象 无需手动释放资源 步骤 创建JdbcTemplate类的对象 1JdbcTemplate jdbcTemplate = new JdbcTemplate(连接池) 编写sql语句 执行sql语句 增删改 1int row = jdbcTemplate.update(\"sql语句\",占位符); 查 单表 单个对象 基本数据类型 1jdbcTemplate.queryForObject(\"sql语句\",包装类型.class,占位符) pojo对象 1jdbcTemplate.queryForObject(\"sql语句\",new BeanPropertyRowMapper&lt;&gt;(pojo对象.class),占位符) 多个对象 1jdbc.query(\"sql语句\",new BeanPropertyRowMapper&lt;&gt;(pojo对象.class),占位符) 多表 单条数据 12返回值大多为Map&lt;String,Object&gt;jdbcTemplate.queryForMap(“sql语句”, 占位符); 多条数据 12返回值为List&lt;Map&lt;String,Object&gt;&gt;jdbcTemplate.queryForList(“sql语句”, 占位符); Mybatis优点： 支持自定义sql,存储过程,高级映射 实现自动对sql参数的设置 自动对结果集进行解析和封装 通过对xml或注解进行配置和映射,大大减少了代码量 数据源的连接信息通过配置文件进行配置 整体架构 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 SqlSessionFactory 作用:获取SqlSession 123InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession 作用:执行CRUD操作,线程不安全 Executor 执行器 :sqlSession通过调用它来完成具体的CRUD 查 查一个对象 1sqlsession.selectone(XxxMapper.id,占位符) 查一列对象 1sqlsession.selectList(XxxMapper.id,占位符) 增 1sqlsession.insert(XxxMapper.id,占位符) 删 1sqlsession.delete(XxxMapper.id,占位符) 改 1sqlsession.update(XxxMapper.id,占位符) 完整的CRUD操作 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 创建接口和实现类 SqlSessionFactory 作用:获取SqlSession 123InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(true); SqlSession 作用:执行CRUD操作,线程不安全 Executor 执行器 :sqlSession通过调用它来完成具体的CRUD 查 查一个对象 1sqlsession.selectone(XxxMapper.id,占位符) 查一列对象 1sqlsession.selectList(XxxMapper.id,占位符) 增 1sqlsession.insert(XxxMapper.id,占位符) 删 1sqlsession.delete(XxxMapper.id,占位符) 改 1sqlsession.update(XxxMapper.id,占位符) Mapper动态代理方式只写接口，不书写实现类，只编写Mapper.xml即可 Mapper接口的动态代理实现，需要遵循以下规范： 映射文件中的命名空间（名称空间）与Mapper接口的全路径一致 映射文件中的statement的Id与Mapper接口的方法名保持一致 映射文件中的statement的ResultType必须和mapper接口方法的返回类型一致（即使不采用动态代理，也要一致） 映射文件中的statement的parameterType必须和mapper接口方法的参数类型一致（不一定，该参数可省略） 操作步骤 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 创建接口 生成一个代理的实现类 1234InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(true);XxxMapper = sqlSession.getMapper(XxxMapper.class); 执行语句 Xxxmapper.接口方法名(参数);","categories":[],"tags":[]},{"title":"'我的第一篇博客'","date":"2019-06-30T03:50:50.000Z","path":"2019/06/30/我的第一篇博客/","text":"我的第一篇博客https://mumuyouqian.github.io","categories":[],"tags":[]},{"title":"Hello World","date":"2019-06-30T00:53:18.526Z","path":"2019/06/30/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]