[{"title":"String、StringBuilder、StringBuffer三者的区别","date":"2019-09-03T00:03:00.000Z","path":"2019/09/03/tring、StringBuilder、StringBuffer三者的区别/","text":"String和StringBuilder的本质区别 String是一个不可改变的字符序列 1234String s = \"abc\";//这一步是记录了一个新的对象地址，\"abc\"内部的数据根本就没有发生改变s = \"def\";System.out.println(s); StringBuilder是一个可以改变的字符序列 123StringBuilder sb = new StringBuilder(\"aaaaabbbbbccccc\");sb.delete(0,2);System.out.println(sb); 常见的字符串拼接，该选择谁 1234567891011121314151617181920public class Demo_StringBuilder&#123; long start = System.currentTimeMills(); StringBuilder sb = new StringBuilder(); for(int i = 1;i&lt;=100000;i++)&#123; sb.append(i); &#125; System.out.println(sb); long end = System.currentTimeMills(); System.out.println(end-start); //47&#125;private static void getStringResult()&#123; long start = System.currentTimeMills(); String s = \" \"; for(int i = 1;i&lt;=100000;i++)&#123; s+=i; &#125; System.out.println(s); long end = System.currentTimeMills(); System.out.println(end-start); //13526&#125; 推荐使用的是StringBuilder,因为拼接的效率高 String拼接的效率为什么这么慢？ 因为字符串在用”+“号做拼接的时候，每一次都会产生新的字符串 StringBulder无论拼接多少个字符串，都只会产生两个对象 如果在业务层去拼接sql，该使用什么类型去接收？ 如果SQL语句拼接的内容较少的话，可以使用String拼接 但如果SQL语句拼接的内容较多，就应该使用StringBuilder StringBuilder和StringBuffer的区别 StringBuffer和StringBuilder的功能时完全一致的 StringBuffer是jdk1.0出现的，线程安全，效率低 StringBuilder是jdk1.5出现的，线程不安全，效率高","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"Java中的垃圾回收机制","date":"2019-09-02T14:59:00.000Z","path":"2019/09/02/ava中的垃圾回收机制/","text":"什么样的对象会被当做垃圾回收 当一个对象的引用(地址)没有变量去记录的时候，该对象就会成为垃圾对象，并在垃圾回收器空闲的时候对其进行清扫 如何校验对象是否被回收 可以重写Object类中的finalize方法 这个方法在垃圾回收器执行的时候，被回收器自动调用执行的 怎么样通知垃圾回收器回收对象 可以调用System的静态方法gc()通知垃圾回收器去清理垃圾 如何判断哪些对象需要回收 引用计数法(Java中不是使用此方法) 每个对象中添加一个引用计数器，当有别人引用它的时候，计数器就会加1，当别人不引用它的时候，计数器就会减1，当计数器为0的时候对象就可以当成垃圾。算法简单，但是最大问题就是在循环引用时不能把正确对象当成垃圾 123456789101112public class Demo_GC&#123; public static void main(String[] args)&#123; Demo object1 = new Demo(); Demo object2 = new Demo(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; 根搜索算法 这是JVM一般使用的算法，根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系 看作一张图。从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用的节点，即无用的节点 应用场景 尽量不要创建很大的对象 原因：GC回收算法从来不对大对象(&gt;85000字节)堆进行压缩处理，在堆中大的内存块会浪费很多CPU时间 不要频繁的new声明周期很短的对象 这样频繁的垃圾回收频繁压缩可能会导致很多内存碎片","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"GC","slug":"GC","permalink":"http://yoursite.com/tags/GC/"}]},{"title":"创建线程的几种方式","date":"2019-09-02T13:32:00.000Z","path":"2019/09/02/创建线程的几种方式/","text":"继承Thread类 ​ Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己创建的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。 优点：代码简单 缺点：该类无法继承别的类 12345678910111213141516public class ThreadDemo1&#123; ThreadDemo t1 = new ThreadDemo(); t1.setname(\"线程池1\")； t1.start; ThreadDemo t2 = new ThreadDemo(); t2.setname(\"线程池2\")； t2.start;&#125;class ThreadDemo extends Thread&#123; @Override public void run()&#123; for(int i=1;i&lt;=10;i++)&#123; System.out.println(Thread.currentThread().getName()+\":\"+i); &#125; &#125;&#125; 实现Runnable接口 Java中的类属于单继承，如果自己的类已经extends另一个类，就无法直接extends Thread。但是一个类继承一个类同时，是可以实现多个接口的。 优点：继承其他类。统一实现该接口的实例可以共享资源 缺点：代码复杂 12345678910111213141516public class ThreadDemo2&#123; MyThread2 t = new MyThread2(); Thread t1 = new MyThread(t,\"线程池1\"); t1.start; Thread t2 = new MyThread(t,\"线程池2\"); t2.start;&#125;class MyThread2 implements Runnable&#123; @Override public void run()&#123; for(int i=1;i&lt;=10;i++)&#123; System.out.println(Thread.currentThread().getName()+\":\"+i); &#125; &#125;&#125; 实现Callable接口 实现Runnable和实现Callable接口的方式基本相同，不过Callable接口中的call()方法有返回值，Runnable接口中的run()方法无返回值。 1234567891011121314151617public class ThreadDemo3&#123; callable&lt;Object&gt; oneCallable = new Ticket&lt;Object&gt;(); //使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值 FutureTask&lt;Object&gt; oneTask = new FutureTask&lt;Object&gt;(oneCallable); Thread t = new Thread(oneTask,\"线程1\"); t.start; System.out.println(oneTask.get());&#125;class Ticket&lt;String&gt; implements Callable&lt;Object&gt;&#123; @Override public Object call()throws Exception&#123; for(int i=1;i&lt;=10;i++)&#123; System.out.println(i); &#125; return Thread.currentThread().getName()+\"线程执行完毕\"; &#125;&#125; 线程池方式 线程池，其实就是一个容纳多个线程的容器，其中的线程可以重复使用。省去了频繁创建线程对象的操作，因为反复创建线程是非常消耗资源的。 优点：实现自动化装配，易于管理，循环利用资源。 12345678910111213141516public class ThreadDemo4&#123; public static void main(String[] args)&#123; ExecutorService pool = Executors.newFixedThreadPool(2); Future&lt;?&gt; submit = pool.submit(new RunnableThread()); pool.submit(new RunnableThread()); pool.shutdown; &#125;&#125;class RunnableThread implements Runnable&#123; @Override public void run()&#123; for(int i=1;i&lt;=10;i++)&#123; System.out.println(Thread.currentThread().getName()+\":\"+1); &#125; &#125;&#125; Lock接口比synchronized块的优势是什么 能够显示的获取和释放锁，锁的运用更灵活 Lock中的方法: ​ lock()方法：加锁 ​ unlock()方法：释放锁 可以方便的实现公平锁 公平锁：表示线程获取锁的顺序按照线程加锁的顺序来进行分配的，即先得先进先出顺序。 非公平锁：一种获取锁的抢占机制，是随机拿到锁的，和公平锁不一样的是先来的不一定先拿到锁，这个方式可能造成某些线程一直拿不到锁，结果是不公平的。 多线程的应用 吞吐量：举例，做WEB,容器帮你做了多线程，但是它只能帮你做请求层面的。简单的说，可能就是一个请求一个线程，或多个请求一个线程。如果是单线程，那同时只能处理一个请求。 伸缩性：也就是说，可以通过增加CPU核数来提升性能。如果是单线程，那程序执行到死也就利用了单核，肯定没办法通过增加CPU核数来提升性能，如果是多线程，就可以提高CPU的使用性能。","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://yoursite.com/tags/Thread/"}]},{"title":"Java异常处理机制","date":"2019-09-02T05:18:00.000Z","path":"2019/09/02/ava异常处理机制/","text":"什么是异常 异常指的就是程序的不正常，简单理解就是程序所发生的错误 异常的体系结构&amp;分类 分类: 编译时异常：指的就是编译期间，编译器检测到某段代码可能会发生某些问题，需要程序员提前给代码做出错误的解决方案，否则编译是不会通过的 运行时异常：指的是编译通过了，但运行时出现的错误 体系结构： Throwable Error:严重的错误 Exception: RuntimeException 运行时异常 ！RuntimeException 编译时异常 异常产生的原理： java对异常默认处理方式，是将问题抛出给上一级 抛出之前：java会根据错误产生异常类，创建出该类的对象，底层并通过throw关键字将异常抛出给上一级，不断向上抛出，直到抛出给JVM虚拟机，虚拟机拿到问题之后，就会将错误的原因的所在的位置，打印在控制台。 异常的处理方式 1、问题可以自己处理的 try…catch处理方式：自己将问题处理掉，不会影响到后续代码的继续执行。 2、问题自己处理不掉的 ​ throws抛出处理方式: ​ 如果发现问题自己无法解决，就可以通过throw关键字，将异常对象抛出给调用者，但如果使用throw抛出异常对象，则方法上面必须进行throws的声明，告知调用者此方法存在异常 细节：如果抛出的异常对象是RuntimeException,则方法上面无需throws声明 常见问题 Spring框架的事务默认是RuntimeException才进行回滚 解决方案 修改Transactional注解中的rollbackFor属性可以指定exception异常回滚 1@Transactional(rollbackFor=&#123;Exception.class&#125;) 应用场景 编写自定义异常，利用throw抛出自定义异常 自定义异常：其实就是一个规范的异常类名，根据异常类名能够分析出问题所在的原因 如何实现？ 找一个类，继承Exception,或者RuntimeException即可 ​","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Exception","slug":"Exception","permalink":"http://yoursite.com/tags/Exception/"}]},{"title":"共享锁和排他锁","date":"2019-08-29T13:37:00.000Z","path":"2019/08/29/共享锁和排他锁/","text":"一：共享锁 共享锁(读锁)：如果事务对数据加上共享锁后，则其他事务只能对此数据再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。 新建表 12345create table student ( id int, name varchar(15), score int) 插入数据 1insert into student(id,name,score) values(1,&apos;zhangsan&apos;,23) 关闭事务的自动提交 123456#查看：show variables like &apos;%autocommit%&apos;;#开启:set autocommit = 1；#关闭：set autocommit = 0 ; 加共享锁 1select * from student where id = 1 lock in share mode; 对加锁的数据进行修改 1update student set score=322 where id=1; 提示错误 1ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 对加锁的数据进行查询(OK) 1select * from student; 对加锁的数据再次加共享锁(OK) 1select * from student where id = 1 lock in share mode; 对加锁的数据加排他锁(Error) 1select * from student where id = 1 for update; 二：排他锁 排他锁(写锁)：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。 如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。 我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突） 加排他锁 1select * from student where id =1 for update; 对加锁的数据进行修改(Error) 1update student set score=322 where id=1; 对加锁的数据再次加共享锁(Error) 1select * from student where id = 1 lock in share mode; 对加锁的数据加排他锁(Error) 1select * from student where id = 1 for update;","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL中五种时间类型比较","date":"2019-08-18T03:40:00.000Z","path":"2019/08/18/MySQL中五种时间类型比较/","text":"五种时间类型 日期时间类型 占用空间 日期格式 最小值 最大值 零值表示 对应的JAVA时间类型 DATETIME 8 bytes YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 java.sql.Timestamp TIMESTAMP 4 bytes YYYY-MM-DD HH:MM:SS 19700101080001 2038 年的某个时刻 00000000000000 java.sql.Timestamp DATE 4 bytes YYYY-MM-DD 1000-01-01 9999-12-31 0000-00-00 java.sql.Date TIME 3 bytes HH:MM:SS -838:59:59 838:59:59 00:00:00 java.sql.Time YEAR 1 bytes YYYY 1901 2155 0000 java.sql.Date 1. DATETIMEDATETIME用于表示年月日时分秒，是DATE和Time的组合，并且记录的年份（见上表）比较长久。如果实际应用中有这样的需求，就可以使用 DATETIME 类型。 DATETIME列可以设置为多个，默认可为null，可以手动设置其值。 DATETIME列不可设定默认值。 DATETIME列可以变相的设定默认值，比如通过触发器、或者在插入数据时候，将DATETIME字段值设置为now()，这样可以做到了，尤其是后者，在程序开发中常常用到。 2. TIMESTAMP 表示年月日时分秒，必须有默认值，默认值可以为”0000-00-00 00:00:00”,不能为null。 TIMESTAMP和时区相关，更能反映当前时间。插入日期时，会先转换为本地时区后再存放；查询日期时，会将日期转换为本地时区后再显示。所以不同时区的人看到的同一时间是不一样的。 表中的第一个 TIMESTAMP列自动设置为系统时间（CURRENT_TIMESTAMP）。当插入或更新一行，但没有明确给 TIMESTAMP 列赋值，也会自动设置为当前系统时间。如果表中有第二个 TIMESTAMP 列，则默认值设置为0000-00-00 00:00:00,也可以手动设置默认值。 MySQL中，TIMESTAMP可以设置根据时间戳更新,表示每一次修改表中的字段时，此列都会更新为当前系统时间。 注意: 新增一行时，会根据默认值设定类型为TIMESTAMP的值，当修改一行时，会根据是不是设定了根据时间戳更新。如果设定了，则更新为当前时间，否则，不会变化。 3. DATE DATE 用于表示 年月日，如果实际应用值需要保存 年月日 就可以使用 DATE。 4. TIME TIME 用于表示 时分秒，如果实际应用值需要保存 时分秒 就可以使用 TIME。 5. YEAR YEAR 用于表示 年份，YEAR 有 2 位（最好使用4位）和 4 位格式的年。 默认是4位。如果实际应用只保存年份，那么用 1 bytes 保存 YEAR 类型完全可以。不但能够节约存储空间，还能提高表的操作效率。","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Dubbo","date":"2019-08-14T00:24:00.000Z","path":"2019/08/14/Dubbo总结/","text":"浅谈Dubbo 什么是Dubbo Dubbo是分布式RPC框架 Dubbo的三大核心能力 面向接口的远程方法调用 智能容错和负载均衡 服务自动注册和发现 Dubbo架构图 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo使用步骤 服务端 定义一个接口，如： 123public interface CheckitemService &#123; void add(CheckItem checkItem);&#125; 写实现类 1234567891011121314@Service(interfaceClass = CheckitemService.class)@Transactionalpublic class CheckitemServiceImpl implements CheckitemService&#123; @Autowired private CheckitemDao checkitemDao; /** * 新增检查项 * @param checkItem */ @Override public void add(CheckItem checkItem) &#123; checkitemDao.add(checkItem); &#125;&#125; 写事务的配置文件 12345678910&lt;!--事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--开启事务控制的注解支持 注意：此处必须加入proxy-target-class=\"true\" 需要进行事务控制，会由Spring框架产生代理对象 Dubbo需要将Service发布为服务，要求必须使用cglib创建代理对象 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; 写服务端配置文件 12345678&lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;!-- 指定应用名称 --&gt;&lt;dubbo:application name=\"health_service\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!--批量扫描--&gt;&lt;dubbo:annotation package=\"com.itheima.service\"/&gt; @service注解可以写成xml配置文件的形式 12345678910&lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;!-- 指定应用名称 --&gt;&lt;dubbo:application name=\"health_service\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!-- 注册一个Bean --&gt;&lt;bean id=\"checkitemService\" class=\"cn.itcast.dubbo.service.impl.CheckitemServiceImpl\"&gt;&lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface=\"cn.itcast.dubbo.service.CheckitemService\" ref=\"checkitemService\"/&gt; 注意:在一个实现类(CheckitemServiceImpl)加上@Transactional注解时,Spring会为此类基于JDK动态代理技术创建代理对象,如com.sun.proxy.$Proxy42,而我们在xml文件中注册Bean的时候，使用的class仍然为CheckitemServiceImpl,所以就会出现服务提供者无法注册到Dubbo中的情况。 解决方法: 第一步：在服务端事务的配置文件中开启事务控制的注解支持 1&lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; 第二步：在Service注解中加入interfaceClass属性，值为CheckitemService.class，作用是指定服务的接口类型。此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是CheckitemService接口。 消费端 配置文件 123456&lt;!--指定应用名称--&gt;&lt;dubbo:application name=\"health_web\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!--批量扫描--&gt;&lt;dubbo:annotation package=\"com.itheima.controller\"/&gt; 订阅服务 1234567@RestController //将当前处理器中所有方法的返回值都转换成json数据.@RequestMapping(\"/checkitem\")public class CheckitemController &#123; @Reference private CheckitemService checkitemService;&#125; 问题：在服务消费者工程(dubbodemo_consumer)中只是引用了CheckitemService接口，并没有提供实现类，Dubbo是如何做到远程调用的？ Dubbo底层是基于代理技术为CheckitemService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。 启动时检查 1&lt;dubbo:consumer check=\"false\"/&gt; ​ 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。建议在开发阶段将check值设置为false，在生产环境下改为true。 负载均衡 ​ 负载均衡(Load Balance):其实就是将请求分摊到多个操作单元上执行，从而共同完成工作任务。在集群负载均衡时，dubbo提供了多种均衡策略(包括随机(random))、轮询(roundrobin)、最少活跃调用数、一致性Hash),缺省为random随机调用。配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 服务提供者 123456789101112131415//在服务提供者一方配置负载均衡@Service(interfaceClass = CheckitemService.class,loadbalance = \"roundrobin\")@Transactionalpublic class CheckitemServiceImpl implements CheckitemService&#123; @Autowired private CheckitemDao checkitemDao; /** * 新增检查项 * @param checkItem */ @Override public void add(CheckItem checkItem) &#123; checkitemDao.add(checkItem); &#125;&#125; 服务消费者 1234567@RestController //将当前处理器中所有方法的返回值都转换成json数据.@RequestMapping(\"/checkitem\")public class CheckitemController &#123; @Reference(check = false, loadbalance = \"roundrobin\") private CheckitemService checkitemService;&#125;","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://yoursite.com/tags/RPC/"},{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"数据库总结","date":"2019-07-28T23:40:00.000Z","path":"2019/07/29/数据库总结/","text":"JAVA连接Mysql数据库的发展JDBC使用步骤 注册驱动 1Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 1Connection conn = DriverManger.getConnection(\"jdbc:mysql://主机:端口/数据库\",\"数据库用户名\",\"数据库密码\"); 获取Statement对象 1Statement stmt = conn.createStatement(); 使用Statement对象执行sql语句 增删改： 12int i = stmt.executeUpdate(\"sql语句\")；i为执行这条sql语句改变的行数 查： 1ResultSet rs = stmt.executeQuery(\"sql语句\")； 释放资源:在java中,释放资源时或者关闭流时,按照先创建后关闭的原则 增删改: 12stmt.close();conn.close(); 查 123rs.close();stmt.close();conn.close(); JDBC的缺点 操作数据库都需要创建连接,操作完成还需要关闭连接 创建连接和关闭连接可能比执行sql需要的时间都长 一个网站需要高频繁访问时数据库,如果短时间频繁的访问数据库服务器,就容易造成服务器的宕机 连接池为什么要使用连接池？ 优点:连接池中保存了一些数据库连接,这些连接时可以重复的.解省了数据库资源的消耗。 c3p0使用步骤 导包 编写连接池配置文件c3p0-config.xml,配置对应的参数 创建连接池对象 1ComPooledDataSource cpds = new ComPooledDataSource(); 从连接池中获取对象 1conn = cpds.getConnection(); 获取发送sql语句的对象 1stmt = cpds.prepareStatement(sql)； 操作数据库 1stmt.executeUpdate; stmt.executeQuery; 释放资源 Druid使用步骤 导包 创建properties文件,设置对应参数 1234url=jdbc:mysql://主机:端口/数据库名username=用户名password=密码driverClassName=com.mysql.jdbc.Driver 加载properties文件到Properties对象中 12Properties info = new Properties();info.load(new fileInputStream(\"配置文件名.properties\"))； 创建连接池,使用配置文件中的参数 1DataSource dataSource = DruidDataSourceFactory.createDataSource(info); 从连接池中获取连接 1conn = dataSource.getConnection(); 获取发送sql语句对象 1pstmt = conn.prepareStatement(\"sql语句\"); 操作数据库 1pstmt.executeQuery();pstmt.executeUpdate(); 释放资源 JdbcTemplate优点: 将查询到的数据直接封装成对象 无需手动释放资源 步骤 创建JdbcTemplate类的对象 1JdbcTemplate jdbcTemplate = new JdbcTemplate(连接池) 编写sql语句 执行sql语句 增删改 1int row = jdbcTemplate.update(\"sql语句\",占位符); 查 单表 单个对象 基本数据类型 1jdbcTemplate.queryForObject(\"sql语句\",包装类型.class,占位符) pojo对象 1jdbcTemplate.queryForObject(\"sql语句\",new BeanPropertyRowMapper&lt;&gt;(pojo对象.class),占位符) 多个对象 1jdbc.query(\"sql语句\",new BeanPropertyRowMapper&lt;&gt;(pojo对象.class),占位符) 多表 单条数据 12返回值大多为Map&lt;String,Object&gt;jdbcTemplate.queryForMap(“sql语句”, 占位符); 多条数据 12返回值为List&lt;Map&lt;String,Object&gt;&gt;jdbcTemplate.queryForList(“sql语句”, 占位符); Mybatis优点： 支持自定义sql,存储过程,高级映射 实现自动对sql参数的设置 自动对结果集进行解析和封装 通过对xml或注解进行配置和映射,大大减少了代码量 数据源的连接信息通过配置文件进行配置 整体架构 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 SqlSessionFactory 作用:获取SqlSession 123InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession 作用:执行CRUD操作,线程不安全 Executor 执行器 :sqlSession通过调用它来完成具体的CRUD 查 查一个对象 1sqlsession.selectone(XxxMapper.id,占位符) 查一列对象 1sqlsession.selectList(XxxMapper.id,占位符) 增 1sqlsession.insert(XxxMapper.id,占位符) 删 1sqlsession.delete(XxxMapper.id,占位符) 改 1sqlsession.update(XxxMapper.id,占位符) 完整的CRUD操作 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 创建接口和实现类 SqlSessionFactory 作用:获取SqlSession 123InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(true); SqlSession 作用:执行CRUD操作,线程不安全 Executor 执行器 :sqlSession通过调用它来完成具体的CRUD 查 查一个对象 1sqlsession.selectone(XxxMapper.id,占位符) 查一列对象 1sqlsession.selectList(XxxMapper.id,占位符) 增 1sqlsession.insert(XxxMapper.id,占位符) 删 1sqlsession.delete(XxxMapper.id,占位符) 改 1sqlsession.update(XxxMapper.id,占位符) Mapper动态代理方式只写接口，不书写实现类，只编写Mapper.xml即可 Mapper接口的动态代理实现，需要遵循以下规范： 映射文件中的命名空间（名称空间）与Mapper接口的全路径一致 映射文件中的statement的Id与Mapper接口的方法名保持一致 映射文件中的statement的ResultType必须和mapper接口方法的返回类型一致（即使不采用动态代理，也要一致） 映射文件中的statement的parameterType必须和mapper接口方法的参数类型一致（不一定，该参数可省略） 操作步骤 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 创建接口 生成一个代理的实现类 1234InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(true);XxxMapper = sqlSession.getMapper(XxxMapper.class); 执行语句 Xxxmapper.接口方法名(参数);","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]}]