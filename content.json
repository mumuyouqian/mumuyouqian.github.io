[{"title":"共享锁和排他锁","date":"2019-08-29T13:37:00.000Z","path":"2019/08/29/共享锁和排他锁/","text":"一：共享锁 共享锁(读锁)：如果事务对数据加上共享锁后，则其他事务只能对此数据再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。 新建表 12345create table student ( id int, name varchar(15), score int) 插入数据 1insert into student(id,name,score) values(1,&apos;zhangsan&apos;,23) 关闭事务的自动提交 123456#查看：show variables like &apos;%autocommit%&apos;;#开启:set autocommit = 1；#关闭：set autocommit = 0 ; 加共享锁 1select * from student where id = 1 lock in share mode; 对加锁的数据进行修改 1update student set score=322 where id=1; 提示错误 1ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 对加锁的数据进行查询(OK) 1select * from student; 对加锁的数据再次加共享锁(OK) 1select * from student where id = 1 lock in share mode; 对加锁的数据加排他锁(Error) 1select * from student where id = 1 for update; 二：排他锁 排他锁(写锁)：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。 如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。 我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突） 加排他锁 1select * from student where id =1 for update; 对加锁的数据进行修改(Error) 1update student set score=322 where id=1; 对加锁的数据再次加共享锁(Error) 1select * from student where id = 1 lock in share mode; 对加锁的数据加排他锁(Error) 1select * from student where id = 1 for update;","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL中五种时间类型比较","date":"2019-08-18T03:40:00.000Z","path":"2019/08/18/MySQL中五种时间类型比较/","text":"五种时间类型 日期时间类型 占用空间 日期格式 最小值 最大值 零值表示 对应的JAVA时间类型 DATETIME 8 bytes YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 java.sql.Timestamp TIMESTAMP 4 bytes YYYY-MM-DD HH:MM:SS 19700101080001 2038 年的某个时刻 00000000000000 java.sql.Timestamp DATE 4 bytes YYYY-MM-DD 1000-01-01 9999-12-31 0000-00-00 java.sql.Date TIME 3 bytes HH:MM:SS -838:59:59 838:59:59 00:00:00 java.sql.Time YEAR 1 bytes YYYY 1901 2155 0000 java.sql.Date 1. DATETIMEDATETIME用于表示年月日时分秒，是DATE和Time的组合，并且记录的年份（见上表）比较长久。如果实际应用中有这样的需求，就可以使用 DATETIME 类型。 DATETIME列可以设置为多个，默认可为null，可以手动设置其值。 DATETIME列不可设定默认值。 DATETIME列可以变相的设定默认值，比如通过触发器、或者在插入数据时候，将DATETIME字段值设置为now()，这样可以做到了，尤其是后者，在程序开发中常常用到。 2. TIMESTAMP 表示年月日时分秒，必须有默认值，默认值可以为”0000-00-00 00:00:00”,不能为null。 TIMESTAMP和时区相关，更能反映当前时间。插入日期时，会先转换为本地时区后再存放；查询日期时，会将日期转换为本地时区后再显示。所以不同时区的人看到的同一时间是不一样的。 表中的第一个 TIMESTAMP列自动设置为系统时间（CURRENT_TIMESTAMP）。当插入或更新一行，但没有明确给 TIMESTAMP 列赋值，也会自动设置为当前系统时间。如果表中有第二个 TIMESTAMP 列，则默认值设置为0000-00-00 00:00:00,也可以手动设置默认值。 MySQL中，TIMESTAMP可以设置根据时间戳更新,表示每一次修改表中的字段时，此列都会更新为当前系统时间。 注意: 新增一行时，会根据默认值设定类型为TIMESTAMP的值，当修改一行时，会根据是不是设定了根据时间戳更新。如果设定了，则更新为当前时间，否则，不会变化。 3. DATE DATE 用于表示 年月日，如果实际应用值需要保存 年月日 就可以使用 DATE。 4. TIME TIME 用于表示 时分秒，如果实际应用值需要保存 时分秒 就可以使用 TIME。 5. YEAR YEAR 用于表示 年份，YEAR 有 2 位（最好使用4位）和 4 位格式的年。 默认是4位。如果实际应用只保存年份，那么用 1 bytes 保存 YEAR 类型完全可以。不但能够节约存储空间，还能提高表的操作效率。","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Dubbo","date":"2019-08-14T00:24:00.000Z","path":"2019/08/14/Dubbo总结/","text":"浅谈Dubbo 什么是Dubbo Dubbo是分布式RPC框架 Dubbo的三大核心能力 面向接口的远程方法调用 智能容错和负载均衡 服务自动注册和发现 Dubbo架构图 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo使用步骤 服务端 定义一个接口，如： 123public interface CheckitemService &#123; void add(CheckItem checkItem);&#125; 写实现类 1234567891011121314@Service(interfaceClass = CheckitemService.class)@Transactionalpublic class CheckitemServiceImpl implements CheckitemService&#123; @Autowired private CheckitemDao checkitemDao; /** * 新增检查项 * @param checkItem */ @Override public void add(CheckItem checkItem) &#123; checkitemDao.add(checkItem); &#125;&#125; 写事务的配置文件 12345678910&lt;!--事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--开启事务控制的注解支持 注意：此处必须加入proxy-target-class=\"true\" 需要进行事务控制，会由Spring框架产生代理对象 Dubbo需要将Service发布为服务，要求必须使用cglib创建代理对象 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; 写服务端配置文件 12345678&lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;!-- 指定应用名称 --&gt;&lt;dubbo:application name=\"health_service\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!--批量扫描--&gt;&lt;dubbo:annotation package=\"com.itheima.service\"/&gt; @service注解可以写成xml配置文件的形式 12345678910&lt;!--指定暴露服务的端口，如果不指定默认为20880--&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;!-- 指定应用名称 --&gt;&lt;dubbo:application name=\"health_service\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!-- 注册一个Bean --&gt;&lt;bean id=\"checkitemService\" class=\"cn.itcast.dubbo.service.impl.CheckitemServiceImpl\"&gt;&lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface=\"cn.itcast.dubbo.service.CheckitemService\" ref=\"checkitemService\"/&gt; 注意:在一个实现类(CheckitemServiceImpl)加上@Transactional注解时,Spring会为此类基于JDK动态代理技术创建代理对象,如com.sun.proxy.$Proxy42,而我们在xml文件中注册Bean的时候，使用的class仍然为CheckitemServiceImpl,所以就会出现服务提供者无法注册到Dubbo中的情况。 解决方法: 第一步：在服务端事务的配置文件中开启事务控制的注解支持 1&lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; 第二步：在Service注解中加入interfaceClass属性，值为CheckitemService.class，作用是指定服务的接口类型。此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是CheckitemService接口。 消费端 配置文件 123456&lt;!--指定应用名称--&gt;&lt;dubbo:application name=\"health_web\"/&gt;&lt;!--指定服务注册中心地址--&gt;&lt;dubbo:registry address=\"zookeeper://192.168.124.128:2181\"/&gt;&lt;!--批量扫描--&gt;&lt;dubbo:annotation package=\"com.itheima.controller\"/&gt; 订阅服务 1234567@RestController //将当前处理器中所有方法的返回值都转换成json数据.@RequestMapping(\"/checkitem\")public class CheckitemController &#123; @Reference private CheckitemService checkitemService;&#125; 问题：在服务消费者工程(dubbodemo_consumer)中只是引用了CheckitemService接口，并没有提供实现类，Dubbo是如何做到远程调用的？ Dubbo底层是基于代理技术为CheckitemService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。 启动时检查 1&lt;dubbo:consumer check=\"false\"/&gt; ​ 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。建议在开发阶段将check值设置为false，在生产环境下改为true。 负载均衡 ​ 负载均衡(Load Balance):其实就是将请求分摊到多个操作单元上执行，从而共同完成工作任务。在集群负载均衡时，dubbo提供了多种均衡策略(包括随机(random))、轮询(roundrobin)、最少活跃调用数、一致性Hash),缺省为random随机调用。配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 服务提供者 123456789101112131415//在服务提供者一方配置负载均衡@Service(interfaceClass = CheckitemService.class,loadbalance = \"roundrobin\")@Transactionalpublic class CheckitemServiceImpl implements CheckitemService&#123; @Autowired private CheckitemDao checkitemDao; /** * 新增检查项 * @param checkItem */ @Override public void add(CheckItem checkItem) &#123; checkitemDao.add(checkItem); &#125;&#125; 服务消费者 1234567@RestController //将当前处理器中所有方法的返回值都转换成json数据.@RequestMapping(\"/checkitem\")public class CheckitemController &#123; @Reference(check = false, loadbalance = \"roundrobin\") private CheckitemService checkitemService;&#125;","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://yoursite.com/tags/dubbo/"}]},{"title":"数据库总结","date":"2019-07-28T23:40:00.000Z","path":"2019/07/29/数据库总结/","text":"JAVA连接Mysql数据库的发展JDBC使用步骤 注册驱动 1Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 1Connection conn = DriverManger.getConnection(\"jdbc:mysql://主机:端口/数据库\",\"数据库用户名\",\"数据库密码\"); 获取Statement对象 1Statement stmt = conn.createStatement(); 使用Statement对象执行sql语句 增删改： 12int i = stmt.executeUpdate(\"sql语句\")；i为执行这条sql语句改变的行数 查： 1ResultSet rs = stmt.executeQuery(\"sql语句\")； 释放资源:在java中,释放资源时或者关闭流时,按照先创建后关闭的原则 增删改: 12stmt.close();conn.close(); 查 123rs.close();stmt.close();conn.close(); JDBC的缺点 操作数据库都需要创建连接,操作完成还需要关闭连接 创建连接和关闭连接可能比执行sql需要的时间都长 一个网站需要高频繁访问时数据库,如果短时间频繁的访问数据库服务器,就容易造成服务器的宕机 连接池为什么要使用连接池？ 优点:连接池中保存了一些数据库连接,这些连接时可以重复的.解省了数据库资源的消耗。 c3p0使用步骤 导包 编写连接池配置文件c3p0-config.xml,配置对应的参数 创建连接池对象 1ComPooledDataSource cpds = new ComPooledDataSource(); 从连接池中获取对象 1conn = cpds.getConnection(); 获取发送sql语句的对象 1stmt = cpds.prepareStatement(sql)； 操作数据库 1stmt.executeUpdate; stmt.executeQuery; 释放资源 Druid使用步骤 导包 创建properties文件,设置对应参数 1234url=jdbc:mysql://主机:端口/数据库名username=用户名password=密码driverClassName=com.mysql.jdbc.Driver 加载properties文件到Properties对象中 12Properties info = new Properties();info.load(new fileInputStream(\"配置文件名.properties\"))； 创建连接池,使用配置文件中的参数 1DataSource dataSource = DruidDataSourceFactory.createDataSource(info); 从连接池中获取连接 1conn = dataSource.getConnection(); 获取发送sql语句对象 1pstmt = conn.prepareStatement(\"sql语句\"); 操作数据库 1pstmt.executeQuery();pstmt.executeUpdate(); 释放资源 JdbcTemplate优点: 将查询到的数据直接封装成对象 无需手动释放资源 步骤 创建JdbcTemplate类的对象 1JdbcTemplate jdbcTemplate = new JdbcTemplate(连接池) 编写sql语句 执行sql语句 增删改 1int row = jdbcTemplate.update(\"sql语句\",占位符); 查 单表 单个对象 基本数据类型 1jdbcTemplate.queryForObject(\"sql语句\",包装类型.class,占位符) pojo对象 1jdbcTemplate.queryForObject(\"sql语句\",new BeanPropertyRowMapper&lt;&gt;(pojo对象.class),占位符) 多个对象 1jdbc.query(\"sql语句\",new BeanPropertyRowMapper&lt;&gt;(pojo对象.class),占位符) 多表 单条数据 12返回值大多为Map&lt;String,Object&gt;jdbcTemplate.queryForMap(“sql语句”, 占位符); 多条数据 12返回值为List&lt;Map&lt;String,Object&gt;&gt;jdbcTemplate.queryForList(“sql语句”, 占位符); Mybatis优点： 支持自定义sql,存储过程,高级映射 实现自动对sql参数的设置 自动对结果集进行解析和封装 通过对xml或注解进行配置和映射,大大减少了代码量 数据源的连接信息通过配置文件进行配置 整体架构 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 SqlSessionFactory 作用:获取SqlSession 123InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession 作用:执行CRUD操作,线程不安全 Executor 执行器 :sqlSession通过调用它来完成具体的CRUD 查 查一个对象 1sqlsession.selectone(XxxMapper.id,占位符) 查一列对象 1sqlsession.selectList(XxxMapper.id,占位符) 增 1sqlsession.insert(XxxMapper.id,占位符) 删 1sqlsession.delete(XxxMapper.id,占位符) 改 1sqlsession.update(XxxMapper.id,占位符) 完整的CRUD操作 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 创建接口和实现类 SqlSessionFactory 作用:获取SqlSession 123InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(true); SqlSession 作用:执行CRUD操作,线程不安全 Executor 执行器 :sqlSession通过调用它来完成具体的CRUD 查 查一个对象 1sqlsession.selectone(XxxMapper.id,占位符) 查一列对象 1sqlsession.selectList(XxxMapper.id,占位符) 增 1sqlsession.insert(XxxMapper.id,占位符) 删 1sqlsession.delete(XxxMapper.id,占位符) 改 1sqlsession.update(XxxMapper.id,占位符) Mapper动态代理方式只写接口，不书写实现类，只编写Mapper.xml即可 Mapper接口的动态代理实现，需要遵循以下规范： 映射文件中的命名空间（名称空间）与Mapper接口的全路径一致 映射文件中的statement的Id与Mapper接口的方法名保持一致 映射文件中的statement的ResultType必须和mapper接口方法的返回类型一致（即使不采用动态代理，也要一致） 映射文件中的statement的parameterType必须和mapper接口方法的参数类型一致（不一定，该参数可省略） 操作步骤 配置文件 全局配置文件:mybatis-config.xml 作用:配置数据源(配置数据库连接信息) 映射文件:XxxMapper.xml 作用:配置sql语句、参数、结果集、数据类型 创建接口 生成一个代理的实现类 1234InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession(true);XxxMapper = sqlSession.getMapper(XxxMapper.class); 执行语句 Xxxmapper.接口方法名(参数);","categories":[{"name":"develop","slug":"develop","permalink":"http://yoursite.com/categories/develop/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]}]